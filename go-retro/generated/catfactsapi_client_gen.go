// Code generated by GoRetro; DO NOT EDIT.
package goretro

import (
	"encoding/json"
	"errors"
	"fmt"
	"github.com/AlterNayte/go-retro/example/cats"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"time"
)

type CatFactsAPIClient struct {
	BaseURL        string
	HTTPClient     *http.Client
	AuthType       AuthType
	Username       string
	Password       string
	APIKey         string
	BearerToken    string
	CustomAuthFunc func() (string, error)
	CustomHeaders  map[string]string
	Timeout        time.Duration
	MaxRetries     int
}

func NewCatFactsAPIClient(baseURL string) *CatFactsAPIClient {
	return &CatFactsAPIClient{
		BaseURL:       baseURL,
		HTTPClient:    &http.Client{},
		AuthType:      AuthNone,
		CustomHeaders: make(map[string]string),
		Timeout:       30 * time.Second,
		MaxRetries:    3,
	}
}

func (c *CatFactsAPIClient) SetBasicAuth(username, password string) {
	c.AuthType = AuthBasic
	c.Username = username
	c.Password = password
}

func (c *CatFactsAPIClient) SetAPIKeyAuth(apiKey string) {
	c.AuthType = AuthAPIKey
	c.APIKey = apiKey
}

func (c *CatFactsAPIClient) SetBearerAuth(token string) {
	c.AuthType = AuthBearer
	c.BearerToken = token
}

func (c *CatFactsAPIClient) SetCustomAuthFunc(authFunc func() (string, error)) {
	c.CustomAuthFunc = authFunc
}

func (c *CatFactsAPIClient) SetCustomHeader(key, value string) {
	c.CustomHeaders[key] = value
}

func (c *CatFactsAPIClient) doRequest(req *http.Request) (*http.Response, error) {
	for k, v := range c.CustomHeaders {
		req.Header.Set(k, v)
	}
	req.Header.Set("Content-Type", "application/json")

	for i := 0; i < c.MaxRetries; i++ {
		c.HTTPClient.Timeout = c.Timeout
		resp, err := c.HTTPClient.Do(req)
		if err != nil {
			if i == c.MaxRetries-1 {
				return nil, err
			}
			time.Sleep(2 * time.Second)
			continue
		}

		if resp.StatusCode >= 200 && resp.StatusCode < 300 {
			return resp, nil
		}

		if i == c.MaxRetries-1 {
			bodyBytes, _ := ioutil.ReadAll(resp.Body)
			return nil, fmt.Errorf("request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
		}

		time.Sleep(2 * time.Second)
	}

	return nil, errors.New("max retries exceeded")
}

func (c *CatFactsAPIClient) Facts() ([]cats.Fact, error) {
	reqURL := c.BaseURL + "/facts"

	req, err := http.NewRequest("GET", reqURL, nil)
	if err != nil {
		return nil, err
	}

	log.Printf("Making request to %s", req.URL)

	resp, err := c.doRequest(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result []cats.Fact
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}

func (c *CatFactsAPIClient) AnimalFacts(animal_type string) ([]cats.Fact, error) {
	reqURL := c.BaseURL + "/facts"

	query := url.Values{}

	query.Add("animal_type", fmt.Sprintf("%v", animal_type))

	reqURL += "?" + query.Encode()

	req, err := http.NewRequest("GET", reqURL, nil)
	if err != nil {
		return nil, err
	}

	log.Printf("Making request to %s", req.URL)

	resp, err := c.doRequest(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result []cats.Fact
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}

func (c *CatFactsAPIClient) Fact(id string) (*cats.Fact, error) {
	reqURL := c.BaseURL + "/facts/%s"

	reqURL = fmt.Sprintf(reqURL, id)

	req, err := http.NewRequest("GET", reqURL, nil)
	if err != nil {
		return nil, err
	}

	log.Printf("Making request to %s", req.URL)

	resp, err := c.doRequest(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	var result *cats.Fact
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return result, nil
}
